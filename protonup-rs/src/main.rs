use clap::Parser;
use indicatif::{ProgressBar, ProgressDrawTarget, ProgressStyle};
use inquire::{Select, Text};
use std::path::{Path, PathBuf};
use std::{fmt, fs};
use std::{
    sync::{atomic::Ordering, Arc},
    thread,
    time::Duration,
};

use libprotonup::{apps, constants, files, github, utils, variants};

mod file_path;
mod helper_menus;
mod manage_apps;

use helper_menus::{confirm_menu, tag_menu, variants_menu};
use manage_apps::manage_apps_routine;

#[derive(Debug, Parser)]
struct Opt {
    /// Skip Menu and download latest directly
    #[arg(short, long)]
    quick_download: bool,
}

#[derive(Debug, Copy, Clone)]
#[allow(clippy::upper_case_acronyms)]
enum InitialMenu {
    QuickUpdate,
    DoanloadForSteam,
    DoanloadForLutris,
    DownloadIntoCustomLocation,
    ManageExistingInstallations,
}

impl InitialMenu {
    // could be generated by macro
    const VARIANTS: &'static [InitialMenu] = &[
        Self::QuickUpdate,
        Self::DoanloadForSteam,
        Self::DoanloadForLutris,
        Self::DownloadIntoCustomLocation,
        Self::ManageExistingInstallations,
    ];
}

impl fmt::Display for InitialMenu {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            Self::QuickUpdate => write!(f, "Quick Update (detect apps and auto download)"),
            Self::DoanloadForSteam => write!(f, "Download GE Proton for Steam"),
            Self::DoanloadForLutris => write!(f, "Download GE Proton/Wine GE for Lutris"),
            Self::DownloadIntoCustomLocation => {
                write!(f, "Download GE Proton/Wine GE into custom location")
            }
            Self::ManageExistingInstallations => write!(f, "Manage Existing Proton Installations"),
        }
    }
}

#[tokio::main]
async fn main() {
    // run quick downloads and skip InitialMenu
    if run_quick_downloads().await {
        return;
    }

    // Default Parameters
    let source: variants::VariantParameters;
    let mut install_dirs: Vec<String> = vec![];
    let mut tags: Vec<String> = vec![];

    let mut should_open_tag_selector = false;
    let mut should_open_dir_selector = false;
    let mut manage_existing_versions = false;
    let mut should_detect_apps = false;
    let mut apps_to_use: Vec<apps::AppInstallations> = vec![];
    let mut selected_app: Option<apps::App> = None;

    let answer: InitialMenu = Select::new(
        "ProtonUp Menu: Chose your action:",
        InitialMenu::VARIANTS.to_vec(),
    )
    .with_page_size(10)
    .prompt()
    .unwrap_or_else(|_| std::process::exit(0));

    // Set parameters based on users choice
    match answer {
        InitialMenu::QuickUpdate => {
            should_detect_apps = true;
        }
        InitialMenu::DoanloadForSteam => {
            selected_app = Some(apps::App::Steam);
            should_open_tag_selector = true;
        }
        InitialMenu::DoanloadForLutris => {
            selected_app = Some(apps::App::Lutris);
            should_open_tag_selector = true;
        }
        InitialMenu::DownloadIntoCustomLocation => {
            should_open_dir_selector = true;
            should_open_tag_selector = true;
        }
        InitialMenu::ManageExistingInstallations => manage_existing_versions = true,
    }

    // This is where the execution happens

    // If the user wants to manage existing installations, we skip the rest of the menu
    if manage_existing_versions {
        manage_apps_routine();
        return;
    }

    if should_detect_apps {
        apps_to_use = apps::list_installed_apps();
        if apps_to_use.is_empty() {
            println!("Could not find any version of Steam or Lutris. Please install at least one app before using this feature.");
            return;
        }
        println!(
            "Found the following apps: {}",
            apps_to_use
                .iter()
                .map(|app| app.to_string())
                .collect::<Vec<String>>()
                .join(", ")
        );

        // TODO: this should be done in a single place. But here we use the default for every app, and in the other part we install all selected tags for all selected apps
        for app_inst in &apps_to_use {
            let variant = app_inst.into_app().app_default_variant();
            let destination = app_inst.default_install_dir().to_string();
            println!(
                "\nQuick Download: {} for {} into -> {}\n",
                variant,
                app_inst.into_app(),
                destination
            );
            let file = download_file("latest", &variant.parameters())
                .await
                .unwrap();
            unpack_file(&file, &destination, &variant.parameters())
                .await
                .unwrap_or_else(|_| std::process::exit(0));
        }
        return;
    }

    // the rest of th execution is for updating/installing new versions
    if should_open_dir_selector {
        let current_dir = std::env::current_dir().unwrap_or_else(|_| std::process::exit(0));
        let help_message = format!("Current directory: {}", &current_dir.to_string_lossy());
        let answer = Text::new("Installation path:")
            .with_autocomplete(file_path::FilePathCompleter::default())
            .with_help_message(&help_message)
            .with_default(&current_dir.to_string_lossy())
            .prompt();

        match answer {
            Ok(path) => {
                println!("Will use the custom path: {}", path);
                install_dirs.push(path)
            }
            Err(error) => {
                println!("Error choosing custom path. Using the default. Error: {error:?}");
            }
        };
    }

    let source_options = match selected_app {
        Some(app) => app.app_available_variants(),
        None => variants::ALL_VARIANTS.to_vec(),
    };

    if source_options.len() == 1 {
        source = source_options[0].parameters();
        // println!("Chose the only available option: {}", source.)
    } else {
        source = Select::new("Chose the variant you want to install:", source_options)
            .prompt()
            .map(|variant| variant.parameters())
            .unwrap_or_else(|_| std::process::exit(0));
    };

    // if empty, no apps were detected, so we ask the user to chose one
    if apps_to_use.is_empty() && selected_app.is_some() {
        apps_to_use = apps::list_installed_apps();
        if !apps_to_use.is_empty() {
            // filter detected app installations that match selected app
            apps_to_use.retain(|app_inst| app_inst.into_app() == selected_app.unwrap());
            apps_to_use.retain(|app_inst| {
                confirm_menu(
                    format!("Detected {app_inst} installation. Use it?"),
                    String::from("If you have multiple install options, you can chose all of them"),
                    true,
                )
            })
        }

        // if apps_to_use is empty, list default options
        if apps_to_use.is_empty() {
            apps_to_use = variants_menu(
                "Chose the app you want to intall for:",
                selected_app.unwrap().app_installations(),
            )
            .unwrap_or_else(|_| std::process::exit(0));
        }
    }

    // if still no apps were selected
    if apps_to_use.is_empty() && selected_app.is_some() {
        return;
    }

    // past this point, either a path was manually selected or selected_app is not empty
    if install_dirs.is_empty() {
        install_dirs = apps_to_use
            .iter()
            .map(|app_inst| app_inst.default_install_dir().to_string())
            .collect();
    }

    if should_open_tag_selector {
        tags = vec![];
        let release_list = match github::list_releases(&source).await {
            Ok(data) => data,
            Err(e) => {
                eprintln!("Failed to fetch Github data, make sure you're connected to the internet.\nError: {}", e);
                std::process::exit(1)
            }
        };
        let tag_list: Vec<String> = release_list.into_iter().map(|r| (r.tag_name)).collect();
        let list = match tag_menu("Select the versions you want to download :", tag_list) {
            Ok(tags) => tags,
            Err(e) => {
                eprintln!("The tag list could not be processed.\nError: {}", e);
                vec![]
            }
        };
        for tag_iter in list.iter() {
            let tag = String::from(tag_iter);
            tags.push(tag);
        }
    } else {
        let tag = match github::fetch_data_from_tag("latest", &source).await {
            Ok(data) => data,
            Err(e) => {
                eprintln!("Failed to fetch Github data, make sure you're connected to the internet.\nError: {}", e);
                std::process::exit(1)
            }
        };
        tags.push(tag.version)
    }

    tags.retain(|tag_name| {
        // Check if versions exist in disk.
        // If they do, ask the user if it should be overwritten
        !(install_dirs
            .iter()
            .any(|install_dir| files::check_if_exists(install_dir, tag_name))
            && !confirm_menu(
                format!("Version {tag_name} exists in the installation path. Overwrite?"),
                String::from("If you choose yes, you will re-install it."),
                false,
            ))
    });

    // install the versions that are in the tags array, into the locations that are in the install_dirs array
    for tag_name in tags.clone() {
        let tag = match github::fetch_data_from_tag(&tag_name, &source).await {
            Ok(data) => data,
            Err(e) => {
                eprintln!("Failed to fetch Github data, make sure you're connected to the internet.\nError: {}", e);
                std::process::exit(1)
            }
        };

        match download_file(&tag_name, &source).await {
            Ok(file) => {
                // TODO: should just upack once and copy to all folders
                for install_path in &install_dirs {
                    unpack_file(&file, install_path, &source).await.unwrap();
                }
            }
            Err(e) => {
                eprintln!(
                    "Error downloading {}, make sure you're connected to the internet\nError: {}",
                    tag.version, e
                )
            }
        }
    }
}

pub(crate) async fn download_file(
    tag: &str,
    source: &variants::VariantParameters,
) -> Result<PathBuf, String> {
    let mut temp_dir = utils::expand_tilde(constants::TEMP_DIR).unwrap();

    let download = match github::fetch_data_from_tag(tag, source).await {
        Ok(data) => data,
        Err(e) => {
            eprintln!("Failed to fetch GitHub data, make sure you're connected to the internet\nError: {}", e);
            std::process::exit(1)
        }
    };

    temp_dir.push(if download.download.ends_with("tar.gz") {
        format!("{}.tar.gz", &download.version)
    } else if download.download.ends_with("tar.xz") {
        format!("{}.tar.xz", &download.version)
    } else {
        eprintln!("Downloaded file wasn't of the expected type. (tar.(gz/xz)");
        std::process::exit(1)
    });

    let git_hash = files::download_file_into_memory(&download.sha512sum)
        .await
        .unwrap();

    if temp_dir.exists() {
        fs::remove_file(&temp_dir).unwrap();
    }

    let (progress, done) = files::create_progress_trackers();
    let progress_read = Arc::clone(&progress);
    let done_read = Arc::clone(&done);
    let url = String::from(&download.download);
    let tmp_dir = String::from(temp_dir.to_str().unwrap());

    // start ProgressBar in another thread
    thread::spawn(move || {
        let pb = ProgressBar::with_draw_target(
            Some(download.size),
            ProgressDrawTarget::stderr_with_hz(20),
        );
        pb.set_style(ProgressStyle::default_bar()
        .template("{msg}\n{spinner:.green} [{elapsed_precise}] [{wide_bar:.cyan/blue}] {bytes}/{total_bytes} ({bytes_per_sec})").unwrap()
        .progress_chars("#>-"));
        pb.set_message(format!("Downloading {}", url.split('/').last().unwrap()));
        let wait_time = Duration::from_millis(50); // 50ms wait is about 20Hz
        loop {
            let newpos = progress_read.load(Ordering::Relaxed);
            pb.set_position(newpos as u64);
            if done_read.load(Ordering::Relaxed) {
                break;
            }
            thread::sleep(wait_time);
        }
        pb.set_message(format!("Downloaded {url} to {tmp_dir}"));
        pb.abandon(); // closes progress bar without blanking terminal

        println!("Checking file integrity"); // This is being printed here because the progress bar needs to be closed before printing.
    });

    files::download_file_progress(
        download.download,
        download.size,
        temp_dir.clone().as_path(),
        progress,
        done,
    )
    .await
    .unwrap();

    if !files::hash_check_file(temp_dir.to_str().unwrap().to_string(), git_hash).unwrap() {
        return Err("Failed checking file hash".to_string());
    }

    Ok(temp_dir)
}

pub(crate) async fn unpack_file(
    dowaload_path: &Path,
    install_path: &str,
    source: &variants::VariantParameters,
) -> Result<(), String> {
    let install_dir = utils::expand_tilde(install_path).unwrap();

    fs::create_dir_all(&install_dir).unwrap();

    println!("Unpacking files into install location. Please wait");
    files::decompress(dowaload_path, install_dir.as_path()).unwrap();
    let source_type = source.variant_type();
    println!(
        "Done! Restart {}. {} installed in {}",
        source_type.intended_application(),
        source_type,
        install_dir.to_string_lossy(),
    );
    Ok(())
}

async fn run_quick_downloads() -> bool {
    let Opt { quick_download } = Opt::parse();

    if quick_download {
        let found_apps = apps::list_installed_apps();
        if found_apps.is_empty() {
            println!("No apps found. Please install at least one app before using this feature.");
            return false;
        }
        println!(
            "Found the following apps: {}",
            found_apps
                .iter()
                .map(|app| app.to_string())
                .collect::<Vec<String>>()
                .join(", ")
        );

        for app_inst in &found_apps {
            let variant = app_inst.into_app().app_default_variant();
            let destination = app_inst.default_install_dir().to_string();
            println!(
                "\nQuick Download: {} for {} into -> {}\n",
                variant,
                app_inst.into_app(),
                destination
            );
            let file = download_file("latest", &variant.parameters())
                .await
                .unwrap();
            unpack_file(&file, &destination, &variant.parameters())
                .await
                .unwrap_or_else(|e| {
                    eprintln!(
                        "Failed unpacking file {} into {}. Error: {}",
                        file.to_string_lossy(),
                        destination,
                        e
                    );
                });
        }
    }

    quick_download
}
