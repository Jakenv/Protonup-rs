use std::fmt;
use structopt::StructOpt;

use inquire::{
    error::InquireResult, formatter::MultiOptionFormatter, list_option::ListOption,
    validator::Validation, MultiSelect, Select,
};
use std::fmt::{Display, Formatter};

use tokio;

#[derive(Debug, StructOpt)]
struct Opt {
    // /// install a specific version
    // #[structopt(short, long)]
    // tag: Option<String>,
    // #[structopt(short, long)]
    // /// list installed versions
    // list: Option<String>,
    // /// remove existing installations
    // #[structopt(short, long)]
    // remove: Option<String>,
    // /// set specific output
    // #[structopt(short, long)]
    // output: Option<String>,
    // /// set installation directory
    // #[structopt(short, long)]
    // dir: Option<String>,
    // /// disable prompts and logs
    /// Skip Menu and download latest direclty
    #[structopt(short, long)]
    quick_download: bool,
    // /// download only
    // #[structopt(long)]
    // download: bool,
    // /// list available versions
    // #[structopt(long)]
    // releases: bool,
}

#[derive(Debug, Copy, Clone)]
#[allow(clippy::upper_case_acronyms)]
enum Menu {
    QuickUpdate,
    ListReleases,
}

impl Menu {
    // could be generated by macro
    const VARIANTS: &'static [Menu] = &[Self::QuickUpdate, Self::ListReleases];
}

impl fmt::Display for Menu {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            Self::QuickUpdate => write!(f, "Quick Update (Download latest GE Proton)"),
            Self::ListReleases => write!(f, "List GE Proton Releases"),
        }
    }
}

async fn tag_menu(options: Vec<String>) {
    let ans = MultiSelect::new("Select the Versions you want to download:", options).prompt();

    match ans {
        Ok(list) => {
            for tag in list.iter() {
                protonup_rs::download_file(tag).await;
            }
        }

        Err(_) => println!("The tag list could not be processed"),
    }
}

#[tokio::main]
async fn main() {
    let Opt {
        // tag,
        // list,
        // remove,
        // output,
        // dir,
        quick_download,
        // download,
        // releases,
    } = Opt::from_args();

    if quick_download {
        protonup_rs::download_file("latest").await;
        return;
    }

    let ans: Menu = Select::new("ProtonUp Menu: Chose your action:", Menu::VARIANTS.to_vec())
        .prompt()
        .unwrap();

    match ans {
        Menu::QuickUpdate => {
            protonup_rs::download_file("latest").await;
            return;
        }
        Menu::ListReleases => {
            let release_list = protonup_rs::github::list_releases().await.unwrap();
            let tag_list: Vec<String> = release_list
                .into_iter()
                .map(|r| (r.tag_name.clone()))
                .collect();
            tag_menu(tag_list).await;
            return;
        }
    }
}
